const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');
const dotenv = require('dotenv');
const { Sequelize, TelegramUser, MessageLog } = require('./models');

dotenv.config();

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const YANDEX_TRACKER_URL = process.env.YANDEX_TRACKER_URL;
const YANDEX_TRACKER_ORG_ID = process.env.YANDEX_TRACKER_ORG_ID;
const YANDEX_TRACKER_OAUTH_TOKEN = process.env.YANDEX_TRACKER_OAUTH_TOKEN;
const YANDEX_TRACKER_QUEUE = process.env.YANDEX_TRACKER_QUEUE;

const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

const states = {};
const SUMMARY = 'SUMMARY';
const DESCRIPTION = 'DESCRIPTION';
const EMAIL = 'EMAIL';
const VERIFICATION = 'VERIFICATION';
const IMAGE = 'IMAGE';

const allowedDomains = ['kurganmk', 'reftp', 'hobbs-it'];
const emailVerificationCodes = {};

const replyKeyboard = {
    reply_markup: {
        keyboard: [['ðŸ“ Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð·Ð°Ð´Ð°Ñ‡Ñƒ', 'âŒ ÐžÑ‚Ð¼ÐµÐ½Ð°']],
        one_time_keyboard: true,
        resize_keyboard: true,
    },
};

const removeKeyboard = {
    reply_markup: {
        remove_keyboard: true,
    },
};

// Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð·Ð°Ð´Ð°Ñ‡Ð¸
const createTask = async (summary, description, login, imagePath) => {
    const headers = {
        'Authorization': `OAuth ${YANDEX_TRACKER_OAUTH_TOKEN}`,
        'X-Cloud-Org-ID': YANDEX_TRACKER_ORG_ID,
    };

    const formData = new FormData();
    formData.append('summary', summary);
    formData.append('description', description);
    formData.append('queue', YANDEX_TRACKER_QUEUE);
    formData.append('followers', login);
    formData.append('author', login);

    if (imagePath) {
        const file = fs.createReadStream(imagePath);
        formData.append('attachments', file);
    }

    try {
        const response = await axios.post(YANDEX_TRACKER_URL, formData, {
            headers: {
                ...headers,
                ...formData.getHeaders(),
            },
        });
        return response.data;
    } catch (error) {
        console.error('Error creating task:', error.response ? error.response.data : error.message);
        throw error;
    } finally {
        if (imagePath) {
            await fs.unlink(imagePath); // Ð£Ð´Ð°Ð»ÑÐµÐ¼ Ñ„Ð°Ð¹Ð» Ð¿Ð¾ÑÐ»Ðµ ÐµÐ³Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ Ð² Ñ‚Ñ€ÐµÐºÐµÑ€
        }
    }
};

// ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const text = msg.text;
    const currentState = states[chatId];

    // Ð›Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
    try {
        await MessageLog.create({ telegramId: chatId, message: text || 'No text in message' });
    } catch (error) {
        console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ:', error);
    }

    // ÐžÑ‚Ð¼ÐµÐ½Ð° Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ
    if (text === 'âŒ ÐžÑ‚Ð¼ÐµÐ½Ð°') {
        delete states[chatId];
        bot.sendMessage(chatId, 'Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð¾Ñ‚Ð¼ÐµÐ½ÐµÐ½Ð¾.', replyKeyboard);
        return;
    }

    // ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ EMAIL
    if (currentState && currentState.state === EMAIL) {
        const email = text;
        const emailParts = email.split('@');
        const domain = emailParts[1] ? emailParts[1].split('.')[0] : '';

        if (!allowedDomains.includes(domain)) {
            bot.sendMessage(chatId, 'ÐÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ñ‹Ð¹ Ð´Ð¾Ð¼ÐµÐ½ Ð¿Ð¾Ñ‡Ñ‚Ñ‹. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ñ€Ð¿Ð¾Ñ€Ð°Ñ‚Ð¸Ð²Ð½ÑƒÑŽ Ð¿Ð¾Ñ‡Ñ‚Ñƒ Ñ Ð´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ñ‹Ð¼ Ð´Ð¾Ð¼ÐµÐ½Ð¾Ð¼ (kurganmk, reftp, hobbs-it).', removeKeyboard);
        } else {
            const login = emailParts[0];
            const code = Math.floor(100000 + Math.random() * 900000);
            emailVerificationCodes[chatId] = code;

            try {
                await sendVerificationEmail(email, code);
                states[chatId].email = email;
                states[chatId].state = VERIFICATION;
                bot.sendMessage(chatId, 'ÐšÐ¾Ð´ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½ Ð½Ð° Ð²Ð°ÑˆÑƒ Ð¿Ð¾Ñ‡Ñ‚Ñƒ. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐµÐ³Ð¾ Ð´Ð»Ñ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸. Ð•ÑÐ»Ð¸ ÐºÐ¾Ð´Ð° Ð½ÐµÑ‚ Ð² Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ð¿Ð°Ð¿ÐºÐµ Ð¿Ð¾Ñ‡Ñ‚Ñ‹, Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð¿Ð°Ð¿ÐºÑƒ Ð¡Ð¿Ð°Ð¼.', removeKeyboard);
            } catch (error) {
                bot.sendMessage(chatId, 'ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐµ ÐºÐ¾Ð´Ð° Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÑÐ½Ð¾Ð²Ð° Ð¿Ð¾Ð·Ð¶Ðµ.', replyKeyboard);
            }
        }
    } else if (currentState && currentState.state === VERIFICATION) {
        const enteredCode = parseInt(text, 10);
        if (emailVerificationCodes[chatId] && emailVerificationCodes[chatId] === enteredCode) {
            const email = currentState.email;
            await TelegramUser.create({ telegramId: chatId, email });
            delete states[chatId];
            bot.sendMessage(chatId, 'ÐŸÐ¾Ñ‡Ñ‚Ð° ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð°. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶ÐµÐ½Ð¸Ñ:', replyKeyboard);
        } else {
            bot.sendMessage(chatId, 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ÐºÐ¾Ð´ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÑÐ½Ð¾Ð²Ð°.', removeKeyboard);
        }
    } else if (text === 'ðŸ“ Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð·Ð°Ð´Ð°Ñ‡Ñƒ') {
        const user = await TelegramUser.findByPk(chatId);
        if (!user) {
            bot.sendMessage(chatId, 'ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°ÑˆÑƒ ÐºÐ¾Ñ€Ð¿Ð¾Ñ€Ð°Ñ‚Ð¸Ð²Ð½ÑƒÑŽ Ð¿Ð¾Ñ‡Ñ‚Ñƒ Ð´Ð»Ñ Ð½Ð°Ñ‡Ð°Ð»Ð°:', removeKeyboard);
            states[chatId] = { state: EMAIL };
        } else {
            states[chatId] = { state: SUMMARY };
            bot.sendMessage(chatId, 'ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð·Ð°Ð´Ð°Ñ‡Ð¸.', removeKeyboard);
        }
    } else if (currentState && currentState.state === SUMMARY) {
        states[chatId].summary = text;
        states[chatId].state = DESCRIPTION;
        bot.sendMessage(chatId, 'Ð¢ÐµÐ¿ÐµÑ€ÑŒ Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð·Ð°Ð´Ð°Ñ‡Ð¸.', {
            reply_markup: {
                keyboard: [['ðŸ”™ ÐÐ°Ð·Ð°Ð´', 'âŒ ÐžÑ‚Ð¼ÐµÐ½Ð°']],
                one_time_keyboard: true,
                resize_keyboard: true,
            },
        });
    } else if (currentState && currentState.state === DESCRIPTION) {
        if (text === 'ðŸ”™ ÐÐ°Ð·Ð°Ð´') {
            states[chatId].state = SUMMARY;
            bot.sendMessage(chatId, 'ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð·Ð°Ð´Ð°Ñ‡Ð¸.', removeKeyboard);
        } else {
            states[chatId].description = text;
            states[chatId].state = IMAGE;
            bot.sendMessage(chatId, 'Ð¥Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ðº Ð·Ð°Ð´Ð°Ñ‡Ðµ? Ð•ÑÐ»Ð¸ Ð½ÐµÑ‚, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ /skip.', {
                reply_markup: {
                    keyboard: [['/skip', 'âŒ ÐžÑ‚Ð¼ÐµÐ½Ð°']],
                    one_time_keyboard: true,
                    resize_keyboard: true,
                },
            });
        }
    } else if (currentState && currentState.state === IMAGE) {
        if (msg.photo) {
            const fileId = msg.photo[msg.photo.length - 1].file_id;
            const filePath = await bot.getFileLink(fileId);
            const imagePath = path.join(__dirname, 'uploads', `${fileId}.jpg`);

            try {
                // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚ Ð»Ð¸ Ð¿Ð°Ð¿ÐºÐ°, Ð¸ ÑÐ¾Ð·Ð´Ð°ÐµÐ¼ ÐµÑ‘, ÐµÑÐ»Ð¸ Ð½ÐµÑ‚
                const uploadDir = path.join(__dirname, 'uploads');
                try {
                    await fs.mkdir(uploadDir, { recursive: true });
                } catch (err) {
                    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸ uploads:', err);
                }

                // Ð¡ÐºÐ°Ñ‡Ð¸Ð²Ð°ÐµÐ¼ Ñ„Ð°Ð¹Ð»
                const response = await axios({
                    url: filePath,
                    method: 'GET',
                    responseType: 'arraybuffer',
                });

                // Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ñ„Ð°Ð¹Ð»
                await fs.writeFile(imagePath, response.data);
                console.log('Ð¤Ð°Ð¹Ð» ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½:', imagePath);

                const { summary, description } = currentState;
                const user = await TelegramUser.findByPk(chatId);

                try {
                    const task = await createTask(summary, description, user.email.split('@')[0], imagePath);
                    bot.sendMessage(chatId, `Ð—Ð°Ð´Ð°Ñ‡Ð° ÑÐ¾Ð·Ð´Ð°Ð½Ð° ÑƒÑÐ¿ÐµÑˆÐ½Ð¾: ${task.key}`, replyKeyboard);
                } catch (error) {
                    bot.sendMessage(chatId, `ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Ð·Ð°Ð´Ð°Ñ‡Ð¸: ${error.message}`, replyKeyboard);
                }
                delete states[chatId];
            } catch (error) {
                console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ:', error);
                bot.sendMessage(chatId, 'ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð·.', replyKeyboard);
                delete states[chatId];
            }
        } else if (text === '/skip') {
            const { summary, description } = currentState;
            const user = await TelegramUser.findByPk(chatId);

            try {
                const task = await createTask(summary, description, user.email.split('@')[0], null);
                bot.sendMessage(chatId, `Ð—Ð°Ð´Ð°Ñ‡Ð° ÑÐ¾Ð·Ð´Ð°Ð½Ð° ÑƒÑÐ¿ÐµÑˆÐ½Ð¾: ${task.key}`, replyKeyboard);
            } catch (error) {
                bot.sendMessage(chatId, `ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Ð·Ð°Ð´Ð°Ñ‡Ð¸: ${error.message}`, replyKeyboard);
            }
            delete states[chatId];
        } else {
            bot.sendMessage(chatId, 'ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ /skip, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ñ€Ð¾Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ ÑÑ‚Ð¾Ñ‚ ÑˆÐ°Ð³.', removeKeyboard);
        }
    }
});

bot.on('polling_error', (error) => {
    console.error('Polling error:', error);
});
