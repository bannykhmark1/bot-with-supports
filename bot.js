const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');
const dotenv = require('dotenv');
const { Sequelize, TelegramUser, MessageLog } = require('./models');

dotenv.config();

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const YANDEX_TRACKER_URL = process.env.YANDEX_TRACKER_URL;
const YANDEX_TRACKER_ORG_ID = process.env.YANDEX_TRACKER_ORG_ID;
const YANDEX_TRACKER_OAUTH_TOKEN = process.env.YANDEX_TRACKER_OAUTH_TOKEN;
const YANDEX_TRACKER_QUEUE = process.env.YANDEX_TRACKER_QUEUE;

const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

const states = {};
const SUMMARY = 'SUMMARY';
const DESCRIPTION = 'DESCRIPTION';
const EMAIL = 'EMAIL';
const VERIFICATION = 'VERIFICATION';
const IMAGE = 'IMAGE';

const allowedDomains = ['kurganmk', 'reftp', 'hobbs-it'];
const emailVerificationCodes = {};

const replyKeyboard = {
    reply_markup: {
        keyboard: [['üìù –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É', '‚ùå –û—Ç–º–µ–Ω–∞']],
        one_time_keyboard: true,
        resize_keyboard: true,
    },
};

const removeKeyboard = {
    reply_markup: {
        remove_keyboard: true,
    },
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏
const createTask = async (summary, description, login, imagePath) => {
    const headers = {
        'Authorization': `OAuth ${YANDEX_TRACKER_OAUTH_TOKEN}`,
        'X-Cloud-Org-ID': YANDEX_TRACKER_ORG_ID,
    };

    const formData = new FormData();
    formData.append('summary', summary);
    formData.append('description', description);
    formData.append('queue', YANDEX_TRACKER_QUEUE);
    formData.append('followers', login);
    formData.append('author', login);

    if (imagePath) {
        const file = fs.createReadStream(imagePath);
        formData.append('attachments', file);
    }

    try {
        const response = await axios.post(YANDEX_TRACKER_URL, formData, {
            headers: {
                ...headers,
                ...formData.getHeaders(),
            },
        });
        return response.data;
    } catch (error) {
        console.error('Error creating task:', error.response ? error.response.data : error.message);
        throw error;
    } finally {
        if (imagePath) {
            await fs.unlink(imagePath); // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ –µ–≥–æ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ —Ç—Ä–µ–∫–µ—Ä
        }
    }
};

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const text = msg.text;
    const currentState = states[chatId];

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π
    try {
        await MessageLog.create({ telegramId: chatId, message: text || 'No text in message' });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
    }

    // –û—Ç–º–µ–Ω–∞ –¥–µ–π—Å—Ç–≤–∏—è
    if (text === '‚ùå –û—Ç–º–µ–Ω–∞') {
        delete states[chatId];
        bot.sendMessage(chatId, '–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.', replyKeyboard);
        return;
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è EMAIL
    if (currentState && currentState.state === EMAIL) {
        const email = text;
        const emailParts = email.split('@');
        const domain = emailParts[1] ? emailParts[1].split('.')[0] : '';

        if (!allowedDomains.includes(domain)) {
            bot.sendMessage(chatId, '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –¥–æ–º–µ–Ω –ø–æ—á—Ç—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—É—é –ø–æ—á—Ç—É —Å –¥–æ–ø—É—Å—Ç–∏–º—ã–º –¥–æ–º–µ–Ω–æ–º (kurganmk, reftp, hobbs-it).', removeKeyboard);
        } else {
            const login = emailParts[0];
            const code = Math.floor(100000 + Math.random() * 900000);
            emailVerificationCodes[chatId] = code;

            try {
                await sendVerificationEmail(email, code);
                states[chatId].email = email;
                states[chatId].state = VERIFICATION;
                bot.sendMessage(chatId, '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à—É –ø–æ—á—Ç—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –µ–≥–æ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏. –ï—Å–ª–∏ –∫–æ–¥–∞ –Ω–µ—Ç –≤ –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞–ø–∫–µ –ø–æ—á—Ç—ã, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞–ø–∫—É –°–ø–∞–º.', removeKeyboard);
            } catch (error) {
                bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ.', replyKeyboard);
            }
        }
    } else if (currentState && currentState.state === VERIFICATION) {
        const enteredCode = parseInt(text, 10);
        if (emailVerificationCodes[chatId] && emailVerificationCodes[chatId] === enteredCode) {
            const email = currentState.email;
            await TelegramUser.create({ telegramId: chatId, email });
            delete states[chatId];
            bot.sendMessage(chatId, '–ü–æ—á—Ç–∞ —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è:', replyKeyboard);
        } else {
            bot.sendMessage(chatId, '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.', removeKeyboard);
        }
    } else if (text === 'üìù –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É') {
        const user = await TelegramUser.findByPk(chatId);
        if (!user) {
            bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à—É –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—É—é –ø–æ—á—Ç—É –¥–ª—è –Ω–∞—á–∞–ª–∞:', removeKeyboard);
            states[chatId] = { state: EMAIL };
        } else {
            states[chatId] = { state: SUMMARY };
            bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏.', removeKeyboard);
        }
    } else if (currentState && currentState.state === SUMMARY) {
        states[chatId].summary = text;
        states[chatId].state = DESCRIPTION;
        bot.sendMessage(chatId, '–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏.', {
            reply_markup: {
                keyboard: [['üîô –ù–∞–∑–∞–¥', '‚ùå –û—Ç–º–µ–Ω–∞']],
                one_time_keyboard: true,
                resize_keyboard: true,
            },
        });
    } else if (currentState && currentState.state === DESCRIPTION) {
        if (text === 'üîô –ù–∞–∑–∞–¥') {
            states[chatId].state = SUMMARY;
            bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏.', removeKeyboard);
        } else {
            states[chatId].description = text;
            states[chatId].state = IMAGE;
            bot.sendMessage(chatId, '–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫ –∑–∞–¥–∞—á–µ? –ï—Å–ª–∏ –Ω–µ—Ç, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /skip.', {
                reply_markup: {
                    keyboard: [['/skip', '‚ùå –û—Ç–º–µ–Ω–∞']],
                    one_time_keyboard: true,
                    resize_keyboard: true,
                },
            });
        }
    } else if (currentState && currentState.state === IMAGE) {
        if (msg.photo) {
            const fileId = msg.photo[msg.photo.length - 1].file_id;
            const filePath = await bot.getFileLink(fileId);
            const imagePath = path.join(__dirname, 'uploads', `${fileId}.jpg`);

            try {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–∞–ø–∫–∞, –∏ —Å–æ–∑–¥–∞–µ–º –µ—ë, –µ—Å–ª–∏ –Ω–µ—Ç
                const uploadDir = path.join(__dirname, 'uploads');
                try {
                    await fs.mkdir(uploadDir, { recursive: true });
                } catch (err) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ uploads:', err);
                }

                // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
                const response = await axios({
                    url: filePath,
                    method: 'GET',
                    responseType: 'arraybuffer',
                });

                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
                await fs.writeFile(imagePath, response.data);
                console.log('–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω:', imagePath);

                const { summary, description } = currentState;
                const user = await TelegramUser.findByPk(chatId);

                try {
                    const task = await createTask(summary, description, user.email.split('@')[0], imagePath);
                    bot.sendMessage(chatId, `–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ: ${task.key}`, replyKeyboard);
                } catch (error) {
                    bot.sendMessage(chatId, `–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏: ${error.message}`, replyKeyboard);
                }
                delete states[chatId];
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
                bot.sendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.', replyKeyboard);
                delete states[chatId];
            }
        } else if (text === '/skip') {
            const { summary, description } = currentState;
            const user = await TelegramUser.findByPk(chatId);

            try {
                const task = await createTask(summary, description, user.email.split('@')[0], null);
                bot.sendMessage(chatId, `–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ: ${task.key}`, replyKeyboard);
            } catch (error) {
                bot.sendMessage(chatId, `–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏: ${error.message}`, replyKeyboard);
            }
            delete states[chatId];
        } else {
            bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /skip, —á—Ç–æ–±—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —ç—Ç–æ—Ç —à–∞–≥.', removeKeyboard);
        }
    }
});

bot.on('polling_error', (error) => {
    console.error('Polling error:', error);
});
