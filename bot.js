const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');
const dotenv = require('dotenv');
const nodemailer = require('nodemailer');
const fs = require('fs');
const path = require('path');
const { sequelize, TelegramUser, MessageLog, Image } = require('./models'); // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥–µ–ª–∏

dotenv.config();

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const YANDEX_TRACKER_URL = process.env.YANDEX_TRACKER_URL;
const YANDEX_TRACKER_ORG_ID = process.env.YANDEX_TRACKER_ORG_ID;
const YANDEX_TRACKER_OAUTH_TOKEN = process.env.YANDEX_TRACKER_OAUTH_TOKEN;
const YANDEX_TRACKER_QUEUE = process.env.YANDEX_TRACKER_QUEUE;

const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

const states = {};
const SUMMARY = 'SUMMARY';
const DESCRIPTION = 'DESCRIPTION';
const EMAIL = 'EMAIL';
const VERIFICATION = 'VERIFICATION';
const IMAGE = 'IMAGE';

const allowedDomains = ['kurganmk', 'reftp', 'hobbs-it'];
const emailVerificationCodes = {};

const transporter = nodemailer.createTransport({
    host: 'connect.smtp.bz',
    port: 587,
    secure: false,
    auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
    },
});

const sendVerificationEmail = async (email, code) => {
    const htmlContent = `
        <div style="font-family: Arial, sans-serif; line-height: 1.5; color: #333;">
            <h2 style="color: #4CAF50;">–ö–æ–¥ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏</h2>
            <p>–í–∞—à –∫–æ–¥ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏: <strong style="font-size: 1.2em;">${code}</strong></p>
            <p>–í–≤–µ–¥–∏—Ç–µ –µ–≥–æ –≤ –¢–µ–ª–µ–≥—Ä–∞–º –±–æ—Ç–µ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É.</p>
            <p>–°–ø–∞—Å–∏–±–æ!</p>
            <p style="color: #999; font-size: 0.9em;">–≠—Ç–æ –ø–∏—Å—å–º–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ –æ—Ç–≤–µ—á–∞–π—Ç–µ –Ω–∞ –Ω–µ–≥–æ.</p>
        </div>
    `;

    try {
        await transporter.sendMail({
            from: process.env.EMAIL_USER,
            to: email,
            subject: '–ö–æ–¥ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏',
            html: htmlContent,
        });
        console.log('Verification email sent successfully');
    } catch (error) {
        console.error('Error sending verification email:', error);
        throw error;
    }
};

const replyKeyboard = {
    reply_markup: {
        keyboard: [['üìù –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É', '‚ùå –û—Ç–º–µ–Ω–∞']],
        one_time_keyboard: true,
        resize_keyboard: true,
    },
};

const removeKeyboard = {
    reply_markup: {
        remove_keyboard: true,
    },
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
const saveImageToDatabase = async (telegramId, fileName, filePath) => {
    try {
        const data = fs.readFileSync(filePath);

        await Image.create({
            telegramId,
            fileName,
            data,
        });

        fs.unlinkSync(filePath);
    } catch (error) {
        console.error('Error saving image to database:', error);
        throw error;
    }
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
const getImageFromDatabase = async (telegramId, fileName) => {
    try {
        const image = await Image.findOne({
            where: {
                telegramId,
                fileName,
            },
        });

        if (image) {
            return image.data; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∏–Ω–∞—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        } else {
            throw new Error('Image not found');
        }
    } catch (error) {
        console.error('Error retrieving image from database:', error);
        throw error;
    }
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
const deleteImageFromDatabase = async (telegramId, fileName) => {
    try {
        await Image.destroy({
            where: {
                telegramId,
                fileName,
            },
        });
    } catch (error) {
        console.error('Error deleting image from database:', error);
        throw error;
    }
};

const createTask = async (summary, description, login, imageData) => {
    const headers = {
        'Authorization': `OAuth ${YANDEX_TRACKER_OAUTH_TOKEN}`,
        'X-Cloud-Org-ID': YANDEX_TRACKER_ORG_ID,
    };

    const formData = new FormData();
    formData.append('summary', summary);
    formData.append('description', description);
    formData.append('queue', YANDEX_TRACKER_QUEUE);
    formData.append('followers', login);
    formData.append('author', login);

    if (imageData) {
        formData.append('attachments', imageData, { filename: 'image.jpg' });
    }

    try {
        const response = await axios.post(YANDEX_TRACKER_URL, formData, {
            headers: {
                ...headers,
                ...formData.getHeaders(),
            },
        });
        return response.data;
    } catch (error) {
        console.error('Error creating task:', error.response ? error.response.data : error.message);
        throw error;
    }
};

bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;
    delete states[chatId];

    const user = await TelegramUser.findByPk(chatId);
    if (user) {
        bot.sendMessage(chatId, '–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è:', replyKeyboard);
    } else {
        bot.sendMessage(chatId, '–ü—Ä–∏–≤–µ—Ç! –í–≤–µ–¥–∏—Ç–µ –≤–∞—à—É –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—É—é –ø–æ—á—Ç—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è:', removeKeyboard);
        states[chatId] = { state: EMAIL };
    }
});

bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const text = msg.text;

    console.log('Received message:', text);
    console.log('Current state:', states[chatId]);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Ç–µ–∫—Å—Ç–∞ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏
    if (text) {
        await MessageLog.create({ telegramId: chatId, message: text });
    } else {
        await MessageLog.create({ telegramId: chatId, message: 'No text in message' });
    }

    if (text === '‚ùå –û—Ç–º–µ–Ω–∞') {
        delete states[chatId];
        bot.sendMessage(chatId, '–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.', replyKeyboard);
    } else if (states[chatId] && states[chatId].state === EMAIL) {
        const email = text;
        const emailParts = email.split('@');
        const domain = emailParts[1] ? emailParts[1].split('.')[0] : '';

        if (!allowedDomains.includes(domain)) {
            bot.sendMessage(chatId, '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –¥–æ–º–µ–Ω –ø–æ—á—Ç—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—É—é –ø–æ—á—Ç—É —Å –¥–æ–ø—É—Å—Ç–∏–º—ã–º –¥–æ–º–µ–Ω–æ–º (kurganmk, reftp, hobbs-it).', removeKeyboard);
        } else {
            const login = emailParts[0];
            const code = Math.floor(100000 + Math.random() * 900000);
            emailVerificationCodes[chatId] = code;

            try {
                await sendVerificationEmail(email, code);
                states[chatId].email = email;
                states[chatId].state = VERIFICATION;
                bot.sendMessage(chatId, '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à—É –ø–æ—á—Ç—É. –í–≤–µ–¥–∏—Ç–µ –µ–≥–æ –∑–¥–µ—Å—å:', removeKeyboard);
            } catch (error) {
                bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–∏—Å—å–º–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.', removeKeyboard);
            }
        }
    } else if (states[chatId] && states[chatId].state === VERIFICATION) {
        const code = parseInt(text, 10);
        if (code === emailVerificationCodes[chatId]) {
            delete emailVerificationCodes[chatId];
            states[chatId].state = SUMMARY;
            bot.sendMessage(chatId, '–ü–æ—á—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –í–≤–µ–¥–∏—Ç–µ –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:', removeKeyboard);
        } else {
            bot.sendMessage(chatId, '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
        }
    } else if (states[chatId] && states[chatId].state === SUMMARY) {
        states[chatId].summary = text;
        states[chatId].state = DESCRIPTION;
        bot.sendMessage(chatId, '–í–≤–µ–¥–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:');
    } else if (states[chatId] && states[chatId].state === DESCRIPTION) {
        states[chatId].description = text;
        states[chatId].state = IMAGE;
        bot.sendMessage(chatId, '–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∑–∞–¥–∞—á–∏:');
    } else if (states[chatId] && states[chatId].state === IMAGE) {
        if (msg.photo) {
            const fileId = msg.photo[msg.photo.length - 1].file_id;
            const file = await bot.getFile(fileId);
            const filePath = file.file_path;
            const fileUrl = `https://api.telegram.org/file/bot${TELEGRAM_BOT_TOKEN}/${filePath}`;
            const localFilePath = path.join(__dirname, 'uploads', file.file_id + '.jpg');

            try {
                const response = await axios.get(fileUrl, { responseType: 'arraybuffer' });
                fs.writeFileSync(localFilePath, response.data);

                await saveImageToDatabase(chatId, file.file_id + '.jpg', localFilePath);

                const { summary, description } = states[chatId];
                await createTask(summary, description, states[chatId].email, response.data);

                await deleteImageFromDatabase(chatId, file.file_id + '.jpg');
                bot.sendMessage(chatId, '–ó–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', replyKeyboard);
                delete states[chatId];
            } catch (error) {
                console.error('Error handling image:', error);
                bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.', replyKeyboard);
            }
        } else {
            bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
        }
    } else {
        bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É.');
    }
});
